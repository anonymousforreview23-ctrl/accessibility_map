<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Mental Health Access — US Counties</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <style>
      body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:22px}
      h1{margin:0 0 6px 0}
      .sub{color:#555;margin:0 0 16px 0}
      .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin:12px 0 8px}
      .controls label{font-size:14px}
      #map{width:100%;max-width:1200px;height:760px}
      .note{max-width:1200px;font-size:13px;color:#555}
      .warn{color:#b45309;background:#fff7ed;border:1px solid #fde68a;padding:8px 10px;border-radius:6px;display:none;max-width:1200px;margin:10px 0}
      select{padding:6px 8px}
    </style>
  </head>
  <body>
    <h1>Mental Health Availability & Affordability</h1>
    <p class="sub">Filter by metric and state. Hover counties for details.</p>

    <div id="warn" class="warn"></div>

    <div class="controls">
      <label>
        Metric:
        <select id="metric">
          <option value="AFI_category" selected>Affordability (AFI_category)</option>
          <option value="AVI_category">Availability (AVI_category)</option>
        </select>
      </label>

      <label>
        State:
        <select id="state">
          <option value="__ALL__" selected>All states</option>
        </select>
      </label>
    </div>

    <div id="map"></div>
    <p class="note">Legend: Low → High (quintiles). “No data” = county missing category. Colors are consistent across both metrics.</p>

    <script>
      // ----- CONFIG -----
      const DATA_URL = "data/dataset_for_public.json";
      const GEOJSON_URL = "https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json";

      // Your raw data may use "0–20%" labels; normalize to semantic labels for a consistent legend.
      const RAW_TO_SEM = {
        "0–20%": "Low",
        "20–40%": "Low Average",
        "40–60%": "Average",
        "60–80%": "Above Average",
        "80–100%": "High"
      };
      const CAT_ORDER = ["Low","Low Average","Average","Above Average","High","No data"];
      const COLORS = {
        "Low": "#fef6e4",
        "Low Average": "#fcd5a5",
        "Average": "#f4a261",
        "Above Average": "#a6d96a",
        "High": "#1a9850",
        "No data": "#eeeeee"
      };

      const metricSel = document.getElementById("metric");
      const stateSel  = document.getElementById("state");
      const warnBox   = document.getElementById("warn");
      const mapDiv    = document.getElementById("map");

      let GEOJSON = null;
      let ROWS = [];        // normalized array
      let STATES = [];      // unique states

      // ----- LOAD -----
      Promise.all([ fetch(DATA_URL).then(r => r.json()), fetch(GEOJSON_URL).then(r => r.json()) ])
        .then(([rows, geo]) => {
          GEOJSON = geo;
          if (!Array.isArray(rows) || rows.length === 0) throw new Error("JSON empty or not an array.");

          // Normalize rows
          ROWS = rows.map(d => {
            // figure out state key (State vs state_name)
            const state = d.State ?? d.state_name ?? d.state ?? null;

            // county_fips_str should be 5 chars
            let fips = d.county_fips_str ?? d.county_fips ?? null;
            if (fips != null) fips = String(fips).padStart(5, "0");

            // map category labels if using 0–20% etc.
            const avi_cat = normalizeCat(d.AVI_category);
            const afi_cat = normalizeCat(d.AFI_category);

            // keep optional continuous values for hover if present
            const avi_val = num(d.AVI_county ?? d.AVI_county_wins_05 ?? d.AVI_county_wins);
            const afi_val = num(d.AFI_county ?? d.AFI_county_wins_05 ?? d.AFI_county_wins);

            const county = d.NAMELSAD ?? d.county_name ?? null;

            return {
              fips, state, county,
              AVI_category: avi_cat,
              AFI_category: afi_cat,
              AVI_val: avi_val,
              AFI_val: afi_val
            };
          }).filter(r => r.fips); // must have fips to map

          // Populate state dropdown
          STATES = Array.from(new Set(ROWS.map(r => r.state).filter(Boolean))).sort();
          for (const s of STATES) {
            const opt = document.createElement("option");
            opt.value = s; opt.textContent = s;
            stateSel.appendChild(opt);
          }

          draw(); // initial
        })
        .catch(err => {
          console.error(err);
          mapDiv.innerHTML = "Failed to load data.";
          showWarn(err.message || String(err));
        });

      metricSel.addEventListener("change", draw);
      stateSel.addEventListener("change", draw);

      // ----- DRAW -----
      function draw() {
        const metric = metricSel.value;         // "AFI_category" or "AVI_category"
        const state  = stateSel.value;

        const data = (state === "__ALL__") ? ROWS : ROWS.filter(r => r.state === state);

        // Build arrays for Plotly
        const locations = data.map(r => r.fips);
        const zCats     = data.map(r => r[metric] ?? "No data");
        const hoverText = data.map(r => {
          const avi = formatCat(r.AVI_category);
          const afi = formatCat(r.AFI_category);
          const aviVal = (isFinite(r.AVI_val) ? r.AVI_val.toFixed(3) : "N/A");
          const afiVal = (isFinite(r.AFI_val) ? r.AFI_val.toFixed(3) : "N/A");
          return `<b>${escapeHtml(r.county ?? "County")}, ${escapeHtml(r.state ?? "")}</b><br>` +
                 `AVI: <b>${avi}</b> (${aviVal})<br>` +
                 `AFI: <b>${afi}</b> (${afiVal})<br>` +
                 `FIPS: ${r.fips}`;
        });

        // Map categories to fixed colors
        const zColors = zCats.map(c => COLORS[c] || COLORS["No data"]);

        // For a categorical choropleth in JS, we pass colors via marker colorscale by supplying z as dummy
        // Simpler: use choropleth with 'locations' + geojson and supply 'marker.line.width=0' and 'showscale=false'
        const trace = {
          type: "choropleth",
          geojson: GEOJSON,
          featureidkey: "id",
          locations: locations,
          z: locations.map(() => 1),         // dummy
          text: hoverText,
          hovertemplate: "%{text}<extra></extra>",
          marker: { line: { width: 0 } },
          showscale: false,
          // use per-location color by specifying 'colorscale' + 'z' won't help; instead, use 'marker' with 'colors' isn't supported.
          // Workaround: split by category to multiple traces with distinct colors.
        };

        // Split into per-category traces for true categorical colors + legend
        const traces = [];
        for (const cat of CAT_ORDER) {
          const idx = data.reduce((acc, r, i) => {
            if ((r[metric] ?? "No data") === cat) acc.push(i);
            return acc;
          }, []);
          if (!idx.length) continue;
          traces.push({
            type: "choropleth",
            name: cat,
            geojson: GEOJSON,
            featureidkey: "id",
            locations: idx.map(i => locations[i]),
            z: idx.map(() => 1),
            hovertext: idx.map(i => hoverText[i]),
            hovertemplate: "%{hovertext}<extra></extra>",
            marker: { line: { width: 0 } },
            showscale: false,
            colorscale: [[0, COLORS[cat]], [1, COLORS[cat]]]
          });
        }

        const layout = {
          margin: { l: 0, r: 0, t: 20, b: 0 },
          legend: { orientation: "h", x: 0.5, xanchor: "center", y: -0.05 },
          geo: {
            scope: "usa",
            fitbounds: "locations",
            visible: false,
            projection: { type: "albers usa" },
            showlakes: false,
            showcountries: false,
            showsubunits: true,
            subunitcolor: "black"
          }
        };

        Plotly.react("map", traces, layout, {responsive: true});
      }

      // ----- HELPERS -----
      function normalizeCat(v) {
        if (v == null || v === "") return "No data";
        const s = String(v).trim();
        // map raw "0–20%" style to semantic; otherwise pass through if already semantic
        return RAW_TO_SEM[s] || (CAT_ORDER.includes(s) ? s : "No data");
      }
      function formatCat(s) { return s ?? "No data"; }
      function num(v){ const n = Number(v); return Number.isFinite(n) ? n : NaN; }
      function showWarn(msg){ warnBox.style.display="block"; warnBox.innerHTML = msg; }
      function escapeHtml(str){
        return String(str ?? "").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
      }
    </script>
  </body>
</html>
